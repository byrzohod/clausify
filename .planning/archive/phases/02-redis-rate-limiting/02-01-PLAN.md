# Phase 2 Plan 01: Redis Rate Limiting

**Goal**: Replace in-memory rate limiting with Redis-backed solution for multi-instance scaling

## Context

Current state:
- Rate limiting uses in-memory `Map<string, { count: number; resetTime: number }>`
- Works for single instance but fails with multiple Railway instances
- Same rate limit rules need to be preserved

Target state:
- Redis-backed rate limiting using ioredis
- Sliding window algorithm for better traffic distribution
- Graceful fallback to in-memory if Redis unavailable

## Tasks

### Task 1: Add ioredis and create Redis client singleton

**Files to create:**
- `src/lib/redis.ts` - Redis client singleton with connection handling

**Implementation:**
```typescript
// src/lib/redis.ts
import Redis from 'ioredis';

let redis: Redis | null = null;

export function getRedis(): Redis | null {
  if (!process.env.REDIS_URL) {
    return null;
  }

  if (!redis) {
    redis = new Redis(process.env.REDIS_URL, {
      maxRetriesPerRequest: 3,
      retryStrategy: (times) => Math.min(times * 100, 3000),
      enableReadyCheck: true,
      lazyConnect: true,
    });

    redis.on('error', (err) => {
      console.error('[Redis] Connection error:', err.message);
    });
  }

  return redis;
}
```

**Acceptance:**
- [x] ioredis added to dependencies
- [x] Redis client singleton created
- [x] Connection error handling included
- [x] Lazy connect for serverless compatibility

### Task 2: Create Redis rate limiting helper with sliding window

**Files to create:**
- `src/lib/rate-limit.ts` - Rate limiting logic with Redis and in-memory fallback

**Implementation:**
- Use sliding window counter algorithm
- Atomic operations via Redis MULTI/EXEC
- Fallback to in-memory Map if Redis unavailable
- Same interface as current implementation

**Acceptance:**
- [x] Sliding window algorithm implemented
- [x] Atomic Redis operations
- [x] Graceful fallback to in-memory
- [x] Same rate limit configuration preserved

### Task 3: Update middleware to use Redis rate limiting

**Files to modify:**
- `src/middleware.ts` - Replace in-memory rate limiting with Redis helper

**Changes:**
- Import rate limiting helper
- Replace `checkRateLimit` with Redis-backed version
- Preserve all security headers and CSP
- Preserve rate limit configuration

**Acceptance:**
- [x] Middleware uses Redis rate limiting
- [x] All existing rate limit rules preserved
- [x] Security headers unchanged
- [x] Build passes

### Task 4: Add rate limiting tests

**Files to create:**
- `tests/unit/lib/rate-limit.test.ts` - Unit tests for rate limiting helper

**Test cases:**
- Rate limit allows requests under limit
- Rate limit blocks requests over limit
- Sliding window resets correctly
- Fallback to in-memory when Redis unavailable
- Rate limit key generation (user vs IP)

**Acceptance:**
- [x] All test cases pass
- [x] Redis mocked in tests
- [x] Coverage for fallback behavior

### Task 5: Update documentation and environment

**Files to modify:**
- `.env.example` - Add REDIS_URL
- `CLAUDE.md` - Document Redis requirement

**Acceptance:**
- [x] REDIS_URL documented
- [x] Railway Redis setup documented

## Dependencies

- Phase 1 complete (foundation fixes)
- Railway Redis addon (provisioned separately)

## Risks

1. **Redis connection failures** - Mitigated by in-memory fallback
2. **Clock skew** - Mitigated by using Redis timestamps
3. **Cold start latency** - Mitigated by lazy connect

## Commit Strategy

- Task 1: `feat: add ioredis client singleton`
- Task 2: `feat: add Redis-backed rate limiting with fallback`
- Task 3: `refactor: migrate middleware to Redis rate limiting`
- Task 4: `test: add rate limiting tests`
- Task 5: `docs: add Redis configuration documentation`

---
*Phase: 02-redis-rate-limiting*
*Created: 2026-01-11*
