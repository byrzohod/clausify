---
phase: 01-foundation-fixes
plan: 01
type: execute
---

<objective>
Clean up security issues in auth logging and add observability endpoint.

Purpose: Remove production security risk from debug logging and enable Railway health monitoring.
Output: Secure auth callbacks with environment-gated logging, working /health endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/ARCHITECTURE.md

# Source files:
@src/lib/auth/options.ts
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gate auth debug logging behind development environment</name>
  <files>src/lib/auth/options.ts</files>
  <action>
    Modify the auth callbacks and events to only log in development:

    1. Create a helper at the top of the file:
       ```typescript
       const isDev = process.env.NODE_ENV === 'development';
       const authLog = (message: string, data?: object) => {
         if (isDev) console.log(`[AUTH] ${message}`, data ?? '');
       };
       ```

    2. Replace all console.log calls in callbacks (signIn, jwt, session) with authLog

    3. Replace all console.log calls in events (signIn, signOut, createUser, linkAccount) with authLog

    4. Keep the logger object but gate debug behind isDev:
       ```typescript
       logger: {
         error(code, ...message) {
           console.error('[AUTH ERROR]', code, ...message); // Always log errors
         },
         warn(code, ...message) {
           if (isDev) console.warn('[AUTH WARN]', code, ...message);
         },
         debug(code, ...message) {
           if (isDev) console.log('[AUTH DEBUG]', code, ...message);
         },
       },
       ```

    5. Add a comment documenting allowDangerousEmailAccountLinking:
       ```typescript
       // SECURITY NOTE: allowDangerousEmailAccountLinking is enabled to allow users
       // who signed up with email/password to later link their Google account.
       // Risk: If an attacker controls a Google account with the victim's email,
       // they could gain access. Mitigation: Google verifies email ownership.
       // TODO: Consider requiring email verification before account linking.
       ```

    AVOID: Removing all logging entirely - we need errors logged in production.
    AVOID: Logging sensitive data like passwords or tokens even in dev.
  </action>
  <verify>
    1. `grep -c "console.log" src/lib/auth/options.ts` returns 0 or 1 (only in authLog helper)
    2. `npm run build` succeeds
    3. `npm run lint` passes
  </verify>
  <done>
    - No direct console.log calls in callbacks/events (all use authLog helper)
    - Errors still logged in production
    - Debug/info logging only in development
    - allowDangerousEmailAccountLinking documented with security note
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /health endpoint for Railway monitoring</name>
  <files>src/app/api/health/route.ts</files>
  <action>
    Create a health check endpoint that Railway can use for container orchestration:

    ```typescript
    import { NextResponse } from 'next/server';
    import { prisma } from '@/lib/prisma';

    export const dynamic = 'force-dynamic';
    export const revalidate = 0;

    export async function GET() {
      const start = Date.now();

      try {
        // Check database connectivity
        await prisma.$queryRaw`SELECT 1`;

        const dbLatency = Date.now() - start;

        return NextResponse.json({
          status: 'healthy',
          timestamp: new Date().toISOString(),
          checks: {
            database: { status: 'up', latencyMs: dbLatency },
          },
        });
      } catch (error) {
        console.error('[HEALTH] Database check failed:', error);

        return NextResponse.json({
          status: 'unhealthy',
          timestamp: new Date().toISOString(),
          checks: {
            database: { status: 'down', error: 'Connection failed' },
          },
        }, { status: 503 });
      }
    }
    ```

    AVOID: Including sensitive information in health response.
    AVOID: Making the health check too expensive (just a simple SELECT 1).
  </action>
  <verify>
    1. `curl http://localhost:3000/api/health` returns 200 with healthy status
    2. Response includes database check status
    3. `npm run build` succeeds
  </verify>
  <done>
    - /api/health endpoint exists
    - Returns 200 when database is connected
    - Returns 503 when database is down
    - Response includes timestamp and check details
  </done>
</task>

<task type="auto">
  <name>Task 3: Add health endpoint test</name>
  <files>tests/unit/api/health.test.ts</files>
  <action>
    Create a unit test for the health endpoint:

    ```typescript
    import { describe, it, expect, vi, beforeEach } from 'vitest';

    // Mock prisma before importing the route
    vi.mock('@/lib/prisma', () => ({
      prisma: {
        $queryRaw: vi.fn(),
      },
    }));

    import { GET } from '@/app/api/health/route';
    import { prisma } from '@/lib/prisma';

    describe('/api/health', () => {
      beforeEach(() => {
        vi.clearAllMocks();
      });

      it('returns healthy when database is connected', async () => {
        vi.mocked(prisma.$queryRaw).mockResolvedValue([{ '1': 1 }]);

        const response = await GET();
        const data = await response.json();

        expect(response.status).toBe(200);
        expect(data.status).toBe('healthy');
        expect(data.checks.database.status).toBe('up');
        expect(data.checks.database.latencyMs).toBeGreaterThanOrEqual(0);
      });

      it('returns unhealthy when database fails', async () => {
        vi.mocked(prisma.$queryRaw).mockRejectedValue(new Error('Connection failed'));

        const response = await GET();
        const data = await response.json();

        expect(response.status).toBe(503);
        expect(data.status).toBe('unhealthy');
        expect(data.checks.database.status).toBe('down');
      });
    });
    ```

    AVOID: Testing actual database connection (use mocks).
  </action>
  <verify>
    1. `npm run test:unit -- tests/unit/api/health.test.ts` passes
    2. Both test cases pass
  </verify>
  <done>
    - Health endpoint has test coverage
    - Tests for healthy and unhealthy scenarios
    - Tests use mocked prisma
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] `npm run test:unit` passes
- [ ] No console.log calls directly in auth callbacks (only through authLog helper)
- [ ] /api/health endpoint responds correctly
</verification>

<success_criteria>
- All 3 tasks completed
- All verification checks pass
- Auth debug logging gated behind development environment
- Health endpoint working with database check
- Health endpoint has test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-fixes/01-01-SUMMARY.md` documenting:
- Accomplishments
- Files created/modified
- Any decisions made
- Issues encountered (if any)
- Next step (Phase 2: Redis Rate Limiting)
</output>
